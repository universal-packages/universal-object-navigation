import { resolvePath } from '../src'

describe(resolvePath, (): void => {
  it('cleans up paths and resolve array paths', async (): Promise<void> => {
    expect(resolvePath('')).toBe('')
    expect(resolvePath('/')).toBe('')
    expect(resolvePath('//')).toBe('')
    expect(resolvePath('///')).toBe('')
    expect(resolvePath('////')).toBe('')
    expect(resolvePath('a')).toBe('a')
    expect(resolvePath('/a')).toBe('a')
    expect(resolvePath('//a')).toBe('a')
    expect(resolvePath('///a')).toBe('a')
    expect(resolvePath('////a')).toBe('a')
    expect(resolvePath('a/')).toBe('a')
    expect(resolvePath('a//')).toBe('a')
    expect(resolvePath('a///')).toBe('a')
    expect(resolvePath('a////')).toBe('a')
    expect(resolvePath('/a/')).toBe('a')
    expect(resolvePath('//a//')).toBe('a')
    expect(resolvePath('///a///')).toBe('a')
    expect(resolvePath('////a////')).toBe('a')
    expect(resolvePath('a/b')).toBe('a/b')
    expect(resolvePath('/a/b')).toBe('a/b')
    expect(resolvePath('//a/b')).toBe('a/b')
    expect(resolvePath('///a/b')).toBe('a/b')
    expect(resolvePath('////a/b')).toBe('a/b')
    expect(resolvePath('a/b/')).toBe('a/b')
    expect(resolvePath('a//b')).toBe('a/b')
    expect(resolvePath('a///b')).toBe('a/b')
    expect(resolvePath('a////b')).toBe('a/b')
    expect(resolvePath('/a/b/')).toBe('a/b')
    expect(resolvePath('//a//b')).toBe('a/b')
    expect(resolvePath('///a///b')).toBe('a/b')
    expect(resolvePath('////a////b')).toBe('a/b')

    expect(resolvePath(['a', 'b'])).toBe('a/b')
    expect(resolvePath(['a', 'b', 'c'])).toBe('a/b/c')
    expect(resolvePath(['a/', '/b', 'c/', '/d'])).toBe('a/b/c/d')

    expect(resolvePath(['a', 'b'], '.')).toBe('a.b')
    expect(resolvePath(['a', 'b', 'c'], '.')).toBe('a.b.c')

    expect(resolvePath('....a....b', '.')).toBe('a.b')
    expect(resolvePath('....a....b....c', '.')).toBe('a.b.c')
  })
})
